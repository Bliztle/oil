use crate::ast::{Definition, Program, Ident, Impl, Type, Function, Parameter, Expr, Literal};
use std::str::FromStr;

grammar;

pub programRule: Program = definition* => Program { nodes: <> };

definition: Definition = {
    trait,
    impl,
    mod,
    func => Definition::Func(<>)
}

pub trait: Definition = {
    "trait" <i:ident> => Definition::Trait(i, vec![])
}

pub impl: Definition = {
    "impl" <struct_ident:ident> "{" <f:func+> "}" 
        => Definition::Impl(Impl::Struct(struct_ident, f)),
    "impl" <impl_ident:(<ident> "of")?> <trait_ident:ident> "for" <struct_ident:ident> "{" <f:func+> "}"
        => Definition::Impl(Impl::Trait( impl_ident, trait_ident, struct_ident, f))
}

pub mod: Definition = {
    "mod" => Definition::Mod
}

pub func: Function = {
    "fn" <i:ident> "(" <parameters:parameter*> ")" <return_type:("->" <explicit_type>)?> "{" <body:expr*> "}" => Function { 
        ident: i,
        parameters,
        return_type,
        body
    }
}

pub parameter: Parameter = <i:ident>":"<t:explicit_type> => Parameter { ident: i, parameter_type: t };

pub explicit_type: Type = {
    // Unit type allows for spaces, as parser errors on `fn my_func()` if not, since lexer makes a
    // "()" token
    "(" ")" => Type::Unit,
    "i32" => Type::I32,
    "u32" => Type::U32,
    "(" <parameters:Comma<parameter>?> ")" "->" <return_type:explicit_type> => Type::Function(parameters.unwrap_or(vec![]), return_type.into()),
    ident => Type::Ident(<>)
}

pub expr: Expr = {
    r"[0-9]+" => Expr::Literal(Literal::I32(i32::from_str(<>).unwrap())),
    r"[0-9]?\.[0-9]+" => Expr::Literal(Literal::U32(u32::from_str(<>).unwrap())),
    ident => Expr::Ident(<>)
}

ident: Ident = r"[a-zA-Z_][a-zA-Z_0-9]*" => Ident(<>.into());

// Utility Definitions
Comma<T>: Vec<T> = <mut v:(<T> ",")*><e:T> => { v.push(e); v };
